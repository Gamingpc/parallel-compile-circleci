version: 2

workflows:
  version: 2
  dist-compile:
    jobs:
      - compile
      - link:
          requires: 
            - compile


jobs:

  compile:
    parallelism: 2
    docker:
      - image: gcc:8.2
    steps:
      - checkout
      #split all c files based on the index ID we're running on, pass subset to gcc compile
      - run: circleci tests glob "**/*.c" | circleci tests split --split-by=timings > file_list
      - run: |
          while read LINE;do
            echo "Compiling" $LINE
            TIME=`gcc -ftime-report -c $LINE 2>&1 | grep TOTAL | tr -s " " | cut -d" " -f6`
            echo "<testsuite file=\"$LINE\" time=\"$TIME\"/>" >>timing_body.xml
          done<file_list
      - run: mkdir gcc-timings && cat .circleci/timing_head.xml timing_body.xml .circleci/timing_foot.xml > gcc-timings/timing.xml
      - store_test_results:
          path: gcc-timings
      # move compiled files to specific folder and persist to workspace
      - run: mkdir output && mv *.o output
      - persist_to_workspace:
          root: output
          paths:
            - "*.o"
      # these stpes are debugging only, the timing in this file should align with how files were segmented
      - run: apt-get update && apt-get install -y jq
      - run: echo "previous timings"  && cat $CIRCLE_INTERNAL_TASK_DATA/circle-test-results/results.json | jq '.'

  link:
    docker:
      - image: gcc:8.2
    steps:
      # instead of checking out, restore workspace (will merge all parallel containers from previous job)
      - attach_workspace:
          at: output
      - run: ls -la output
      - run: mv output/* .
      # link the compiled files into an executable
      - run: gcc -o program *.o
      # confirm program exists and is executable
      - run: ls -la
      - run: ./program
      # persist as artifact
      - store_artifacts:
          path: program


